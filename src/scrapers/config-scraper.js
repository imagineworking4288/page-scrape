/**
 * @deprecated This scraper is deprecated. Use v2.3 scrapers from
 * src/scrapers/config-scrapers/ via the createScraper() factory instead.
 *
 * This file is kept for backwards compatibility but should not be used
 * for new development. All CLI paths now route through v2.3 system.
 *
 * Use instead:
 *   const { createScraper, PaginationScraper, SinglePageScraper } = require('./config-scrapers');
 *
 * ---
 *
 * Config Scraper v2.2 (Legacy)
 *
 * Scrapes contacts using v2.0, v2.1, and v2.2 configuration files generated by the
 * Visual Card Scraper. Uses card pattern matching and smart field extraction.
 *
 * Features:
 * - Loads and validates v2.0, v2.1, and v2.2 config files
 * - Uses card pattern matching to find contact cards
 * - v2.2: User-selected extraction with coordinate fallbacks
 * - v2.1: Multi-method extraction with priority fallbacks
 * - v2.0: Smart field extraction rules
 * - Supports pagination (traditional and scroll-based)
 * - Profile page visiting for enrichment
 * - Automatic config version detection and appropriate extraction
 */

const BaseScraper = require('./base-scraper');
const CardMatcher = require('../tools/lib/card-matcher');
const { SmartFieldExtractor, MultiMethodExtractor } = require('../extraction');
const fs = require('fs');
const path = require('path');

class ConfigScraper extends BaseScraper {
  constructor(browserManager, rateLimiter, logger, config = {}) {
    super(browserManager, rateLimiter, logger);

    this.config = config;
    this.cardMatcher = new CardMatcher(logger);
    this.fieldExtractor = new SmartFieldExtractor(logger);
    this.multiMethodExtractor = new MultiMethodExtractor(logger);

    // Detect config version
    this.isV22 = this.isV22Config(config);
    this.isV21 = this.isV21Config(config);

    if (this.isV22) {
      this.logger.info('[ConfigScraper] Using v2.2 user-selected extraction');
    } else if (this.isV21) {
      this.logger.info('[ConfigScraper] Using v2.1 multi-method extraction');
    }
  }

  /**
   * Check if config is v2.2 format
   * @param {Object} config - Configuration to check
   * @returns {boolean} - True if v2.2
   */
  isV22Config(config) {
    return config.version === '2.2' ||
           config.selectionMethod === 'manual' ||
           config.fieldExtraction?.version === '2.2';
  }

  /**
   * Check if config is v2.1 format
   * @param {Object} config - Configuration to check
   * @returns {boolean} - True if v2.1
   */
  isV21Config(config) {
    return config.version === '2.1' ||
           config.fieldExtraction?.version === '2.1' ||
           config.fieldExtraction?.strategy === 'multi-method';
  }

  /**
   * Load configuration from file
   * @param {string} configPath - Path to config file or config name
   * @returns {Object} - Loaded configuration
   */
  loadConfig(configPath) {
    // Try direct path first
    let fullPath = configPath;

    // If not a full path, look in configs directory
    if (!fs.existsSync(fullPath)) {
      fullPath = path.resolve('configs', configPath);
    }

    // Try adding .json extension
    if (!fs.existsSync(fullPath) && !fullPath.endsWith('.json')) {
      fullPath = fullPath + '.json';
    }

    if (!fs.existsSync(fullPath)) {
      throw new Error(`Config file not found: ${configPath}`);
    }

    const content = fs.readFileSync(fullPath, 'utf8');
    const config = JSON.parse(content);

    this.logger.info(`[ConfigScraper] Loaded config: ${config.name} (v${config.version})`);

    return config;
  }

  /**
   * Validate configuration
   * @param {Object} config - Configuration to validate
   * @returns {Object} - Validation result
   */
  validateConfig(config) {
    const errors = [];

    // Check version
    if (!config.version) {
      errors.push('Missing version');
    }

    // For v2.0 configs
    if (config.version === '2.0') {
      if (!config.cardPattern?.selector) {
        errors.push('Missing card pattern selector');
      }
      if (!config.fieldExtraction) {
        errors.push('Missing field extraction configuration');
      }
    }

    // For v1.0 configs
    if (config.version === '1.0' || !config.version) {
      if (!config.selectors?.card) {
        errors.push('Missing card selector');
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors
    };
  }

  /**
   * Main scraping method
   * @param {string} url - URL to scrape
   * @param {number} limit - Maximum contacts to extract
   * @param {boolean} keep - Keep temporary files
   * @param {number} pageNum - Current page number
   * @param {string} sourceUrl - Original source URL
   * @returns {Promise<Array>} - Array of contacts
   */
  async scrape(url, limit = 100, keep = false, pageNum = 1, sourceUrl = null) {
    this.logger.info(`[ConfigScraper] Scraping: ${url} (page ${pageNum})`);

    // Validate config
    const validation = this.validateConfig(this.config);
    if (!validation.valid) {
      this.logger.error(`[ConfigScraper] Invalid config: ${validation.errors.join(', ')}`);
      return [];
    }

    // Get browser page
    const page = await this.browserManager.getPage();
    if (!page) {
      this.logger.error('[ConfigScraper] Failed to get browser page');
      return [];
    }

    try {
      // Navigate to URL
      await page.goto(url, {
        waitUntil: 'networkidle2',
        timeout: 30000
      });

      // Wait for content to load
      const waitSelector = this.getWaitSelector();
      if (waitSelector) {
        try {
          await page.waitForSelector(waitSelector, {
            timeout: this.config.extraction?.waitTimeout || 15000
          });
        } catch (e) {
          this.logger.warn(`[ConfigScraper] Wait selector timeout: ${waitSelector}`);
        }
      }

      // Apply rate limiting
      await this.rateLimiter.wait();

      // Extract contacts based on config version
      let contacts;
      if (this.isV22 || this.config.version === '2.2') {
        // v2.2: User-selected extraction with coordinate fallbacks
        contacts = await this.extractWithV22Config(page, limit);
      } else if (this.isV21 || this.config.version === '2.1') {
        // v2.1: Multi-method extraction with fallbacks
        contacts = await this.extractWithV21Config(page, limit);
      } else if (this.config.version === '2.0') {
        // v2.0: Smart field extraction
        contacts = await this.extractWithV2Config(page, limit);
      } else {
        // v1.0: Basic selector-based extraction
        contacts = await this.extractWithV1Config(page, limit);
      }

      // Enrich from profiles if configured
      if (this.config.profileVisiting?.enabled) {
        const enrichResult = await this.enrichContactsFromProfiles(contacts, page, this.config);
        contacts = enrichResult.enrichedContacts;
      }

      // Add domain info
      contacts.forEach(contact => {
        this.addDomainInfo(contact);
        contact.sourceUrl = sourceUrl || url;
        contact.pageNum = pageNum;
      });

      this.logger.info(`[ConfigScraper] Extracted ${contacts.length} contacts`);

      return contacts;

    } catch (error) {
      this.logger.error(`[ConfigScraper] Scrape error: ${error.message}`);
      return [];
    }
  }

  /**
   * Get wait selector from config
   * @returns {string|null} - Selector to wait for
   */
  getWaitSelector() {
    // v2.2 format
    if (this.config.version === '2.2') {
      return this.config.cardPattern?.primarySelector ||
             this.config.extraction?.waitFor;
    }
    // v2.1 format
    if (this.config.version === '2.1') {
      return this.config.cardPattern?.primarySelector ||
             this.config.extraction?.waitFor;
    }
    // v2.0 format
    if (this.config.version === '2.0') {
      return this.config.cardPattern?.selector || this.config.extraction?.waitFor;
    }
    // v1.0 format
    return this.config.extraction?.waitFor || this.config.selectors?.card;
  }

  /**
   * Get card selector from config (supports v2.0, v2.1, and v2.2)
   * @returns {string|null} - Card selector
   */
  getCardSelector() {
    // v2.2 with fallbacks
    if (this.config.version === '2.2') {
      return this.config.cardPattern?.primarySelector;
    }
    // v2.1 with fallbacks
    if (this.config.version === '2.1') {
      return this.config.cardPattern?.primarySelector;
    }
    // v2.0
    if (this.config.version === '2.0') {
      return this.config.cardPattern?.selector;
    }
    // v1.0
    return this.config.selectors?.card;
  }

  /**
   * Get fallback card selectors (v2.1 and v2.2)
   * @returns {Array<string>} - Fallback selectors
   */
  getFallbackSelectors() {
    if (this.config.version === '2.2' || this.config.version === '2.1') {
      return this.config.cardPattern?.fallbackSelectors || [];
    }
    return [];
  }

  /**
   * Extract contacts using v2.2 configuration (user-selected + coordinates)
   * Uses user-selected selectors with coordinate fallbacks
   * @param {Object} page - Puppeteer page
   * @param {number} limit - Max contacts
   * @returns {Promise<Array>} - Contacts array
   */
  async extractWithV22Config(page, limit) {
    const contacts = [];

    // Get card selector with fallbacks
    let cardSelector = this.getCardSelector();
    const fallbacks = this.getFallbackSelectors();

    // Try primary selector first
    let cardBoxes = await this.findCardBoxes(page, cardSelector);

    // Try fallback selectors if primary fails
    if (cardBoxes.length === 0 && fallbacks.length > 0) {
      this.logger.info('[ConfigScraper v2.2] Primary selector failed, trying fallbacks...');

      for (const fallback of fallbacks) {
        cardBoxes = await this.findCardBoxes(page, fallback);
        if (cardBoxes.length > 0) {
          this.logger.info(`[ConfigScraper v2.2] Fallback selector succeeded: ${fallback}`);
          cardSelector = fallback;
          break;
        }
      }
    }

    this.logger.info(`[ConfigScraper v2.2] Found ${cardBoxes.length} card elements`);

    if (cardBoxes.length === 0) {
      this.logger.warn('[ConfigScraper v2.2] No cards found, trying pattern matching...');
      return await this.extractWithPatternMatching(page, limit);
    }

    // Get field configurations (v2.2 has userSelected and coordinates methods)
    const fieldConfigs = this.config.fieldExtraction?.fields || {};

    // Log v2.2 specific info
    const manualFields = Object.entries(fieldConfigs)
      .filter(([_, cfg]) => cfg.source === 'manual')
      .map(([name]) => name);
    if (manualFields.length > 0) {
      this.logger.info(`[ConfigScraper v2.2] Using manual selections for: ${manualFields.join(', ')}`);
    }

    // Use multi-method extractor (handles userSelected and coordinates types)
    const extractedCards = await this.multiMethodExtractor.extractFromCards(
      page,
      cardBoxes.slice(0, limit),
      fieldConfigs,
      limit
    );

    // Convert to contacts
    extractedCards.forEach(card => {
      // Skip duplicates
      if (card.email && this.isEmailProcessed(card.email)) {
        return;
      }

      const contact = {
        name: card.name || null,
        email: card.email ? card.email.toLowerCase() : null,
        phone: card.phone ? this.normalizePhone(card.phone) : null,
        title: card.title || null,
        location: card.location || null,
        profileUrl: card.profileUrl || null,
        confidence: this.calculateConfidence(card.name, card.email, card.phone),
        // v2.2 metadata
        extractionMethods: card._extractionMethods || {},
        cardIndex: card._cardIndex,
        selectionMethod: 'v2.2-manual'
      };

      if (contact.email) {
        this.markEmailProcessed(contact.email);
      }

      contacts.push(contact);
    });

    // Log extraction stats
    const stats = this.multiMethodExtractor.getStats();
    this.logger.info(`[ConfigScraper v2.2] Extracted ${contacts.length} contacts (manual selection mode)`);

    return contacts;
  }

  /**
   * Extract contacts using v2.1 configuration (multi-method)
   * @param {Object} page - Puppeteer page
   * @param {number} limit - Max contacts
   * @returns {Promise<Array>} - Contacts array
   */
  async extractWithV21Config(page, limit) {
    const contacts = [];

    // Get card selector with fallbacks
    let cardSelector = this.getCardSelector();
    const fallbacks = this.getFallbackSelectors();

    // Try primary selector first
    let cardBoxes = await this.findCardBoxes(page, cardSelector);

    // Try fallback selectors if primary fails
    if (cardBoxes.length === 0 && fallbacks.length > 0) {
      this.logger.info('[ConfigScraper v2.1] Primary selector failed, trying fallbacks...');

      for (const fallback of fallbacks) {
        cardBoxes = await this.findCardBoxes(page, fallback);
        if (cardBoxes.length > 0) {
          this.logger.info(`[ConfigScraper v2.1] Fallback selector succeeded: ${fallback}`);
          cardSelector = fallback;
          break;
        }
      }
    }

    this.logger.info(`[ConfigScraper v2.1] Found ${cardBoxes.length} card elements`);

    if (cardBoxes.length === 0) {
      this.logger.warn('[ConfigScraper v2.1] No cards found, trying pattern matching...');
      return await this.extractWithPatternMatching(page, limit);
    }

    // Get field configurations
    const fieldConfigs = this.config.fieldExtraction?.fields || {};

    // Use multi-method extractor
    const extractedCards = await this.multiMethodExtractor.extractFromCards(
      page,
      cardBoxes.slice(0, limit),
      fieldConfigs,
      limit
    );

    // Convert to contacts
    extractedCards.forEach(card => {
      // Skip duplicates
      if (card.email && this.isEmailProcessed(card.email)) {
        return;
      }

      const contact = {
        name: card.name || null,
        email: card.email ? card.email.toLowerCase() : null,
        phone: card.phone ? this.normalizePhone(card.phone) : null,
        title: card.title || null,
        profileUrl: card.profileUrl || null,
        confidence: this.calculateConfidence(card.name, card.email, card.phone),
        // v2.1 metadata
        extractionMethods: card._extractionMethods || {},
        cardIndex: card._cardIndex
      };

      if (contact.email) {
        this.markEmailProcessed(contact.email);
      }

      contacts.push(contact);
    });

    // Log extraction stats
    const stats = this.multiMethodExtractor.getStats();
    this.logger.info(`[ConfigScraper v2.1] Extracted ${contacts.length} contacts`);

    return contacts;
  }

  /**
   * Find card bounding boxes using selector
   * @param {Object} page - Puppeteer page
   * @param {string} selector - CSS selector
   * @returns {Promise<Array>} - Array of bounding boxes
   */
  async findCardBoxes(page, selector) {
    if (!selector) return [];

    try {
      return await page.evaluate((sel) => {
        const elements = document.querySelectorAll(sel);
        return Array.from(elements).map(el => {
          const rect = el.getBoundingClientRect();
          return {
            x: rect.x + window.scrollX,
            y: rect.y + window.scrollY,
            width: rect.width,
            height: rect.height
          };
        });
      }, selector);
    } catch (error) {
      return [];
    }
  }

  /**
   * Extract contacts using v2.0 configuration
   * @param {Object} page - Puppeteer page
   * @param {number} limit - Max contacts
   * @returns {Promise<Array>} - Contacts array
   */
  async extractWithV2Config(page, limit) {
    const contacts = [];

    // Get card selector
    const cardSelector = this.config.cardPattern?.selector;
    if (!cardSelector) {
      this.logger.error('[ConfigScraper] No card selector in v2.0 config');
      return contacts;
    }

    // Find all card elements
    const cardBoxes = await page.evaluate((selector) => {
      const elements = document.querySelectorAll(selector);
      return Array.from(elements).map(el => {
        const rect = el.getBoundingClientRect();
        return {
          x: rect.x + window.scrollX,
          y: rect.y + window.scrollY,
          width: rect.width,
          height: rect.height
        };
      });
    }, cardSelector);

    this.logger.info(`[ConfigScraper] Found ${cardBoxes.length} card elements`);

    if (cardBoxes.length === 0) {
      // Try pattern-based matching as fallback
      return await this.extractWithPatternMatching(page, limit);
    }

    // Extract fields from each card
    const extractedCards = await this.fieldExtractor.extractFromCards(
      page,
      cardBoxes.slice(0, limit)
    );

    // Convert to contacts
    extractedCards.forEach(card => {
      if (card.email || card.name) {
        // Skip duplicates
        if (card.email && this.isEmailProcessed(card.email)) {
          return;
        }

        const contact = {
          name: card.name || null,
          email: card.email || null,
          phone: card.phone || null,
          title: card.title || null,
          location: card.location || null,
          profileUrl: card.profileUrl || null,
          socialLinks: card.socialLinks || [],
          confidence: this.calculateConfidence(card.name, card.email, card.phone),
          extractionConfidence: card.confidence || 0
        };

        if (card.email) {
          this.markEmailProcessed(card.email);
        }

        contacts.push(contact);
      }
    });

    return contacts;
  }

  /**
   * Extract using pattern matching (fallback)
   * @param {Object} page - Puppeteer page
   * @param {number} limit - Max contacts
   * @returns {Promise<Array>} - Contacts array
   */
  async extractWithPatternMatching(page, limit) {
    this.logger.info('[ConfigScraper] Using pattern-based card matching');

    // Use structural/visual patterns from config
    const pattern = this.config.cardPattern;
    if (!pattern?.structural) {
      this.logger.warn('[ConfigScraper] No structural pattern available');
      return [];
    }

    // Inject and run card matcher with stored pattern
    const matchCode = this.cardMatcher.getMatcherCode();
    await page.evaluate(matchCode);

    // Find cards matching the stored pattern
    const result = await page.evaluate((pattern) => {
      // This is a simplified pattern match
      // In production, we'd use the full structural comparison
      const candidates = document.querySelectorAll(pattern.structural.tagName || '*');
      const matches = [];

      candidates.forEach(el => {
        // Basic size check
        const rect = el.getBoundingClientRect();
        if (pattern.visual?.width) {
          const widthRatio = Math.min(rect.width, pattern.visual.width) /
                            Math.max(rect.width, pattern.visual.width);
          if (widthRatio < 0.5) return;
        }

        // Class pattern check
        if (pattern.structural?.classPatterns?.length > 0) {
          const elClasses = Array.from(el.classList).map(c => c.toLowerCase());
          const hasMatch = pattern.structural.classPatterns.some(p =>
            elClasses.some(c => c.includes(p.replace('*', '')))
          );
          if (!hasMatch) return;
        }

        matches.push({
          x: rect.x + window.scrollX,
          y: rect.y + window.scrollY,
          width: rect.width,
          height: rect.height
        });
      });

      return matches;
    }, pattern);

    // Extract from matched cards
    return await this.fieldExtractor.extractFromCards(page, result.slice(0, limit));
  }

  /**
   * Extract contacts using v1.0 configuration (legacy)
   * @param {Object} page - Puppeteer page
   * @param {number} limit - Max contacts
   * @returns {Promise<Array>} - Contacts array
   */
  async extractWithV1Config(page, limit) {
    const contacts = [];
    const selectors = this.config.selectors;

    if (!selectors?.card) {
      this.logger.error('[ConfigScraper] No card selector in v1.0 config');
      return contacts;
    }

    // Extract using explicit selectors
    const extracted = await page.evaluate((config) => {
      const cards = document.querySelectorAll(config.selectors.card);
      const results = [];

      cards.forEach(card => {
        const data = {};

        // Extract name
        if (config.selectors.fields?.name) {
          const nameEl = card.querySelector(config.selectors.fields.name);
          data.name = nameEl?.textContent?.trim() || null;
        }

        // Extract email
        if (config.selectors.fields?.email) {
          const emailEl = card.querySelector(config.selectors.fields.email);
          data.email = emailEl?.textContent?.trim() || null;
        } else {
          // Try to find email in text
          const emailMatch = card.textContent.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/);
          data.email = emailMatch ? emailMatch[0] : null;
        }

        // Extract phone
        if (config.selectors.fields?.phone) {
          const phoneEl = card.querySelector(config.selectors.fields.phone);
          data.phone = phoneEl?.textContent?.trim() || null;
        }

        if (data.email || data.name) {
          results.push(data);
        }
      });

      return results;
    }, this.config);

    // Convert to contacts
    extracted.slice(0, limit).forEach(data => {
      if (data.email && this.isEmailProcessed(data.email)) {
        return;
      }

      const contact = {
        name: data.name || null,
        email: data.email ? data.email.toLowerCase() : null,
        phone: this.normalizePhone(data.phone),
        confidence: this.calculateConfidence(data.name, data.email, data.phone)
      };

      if (contact.email) {
        this.markEmailProcessed(contact.email);
      }

      contacts.push(contact);
    });

    return contacts;
  }

  /**
   * Scrape with pagination support
   * @param {string} url - Starting URL
   * @param {number} limit - Total contacts limit
   * @param {number} maxPages - Maximum pages to scrape
   * @returns {Promise<Array>} - All contacts
   */
  async scrapeWithPagination(url, limit = 100, maxPages = 10) {
    const allContacts = [];
    let currentUrl = url;
    let pageNum = 1;

    const pagination = this.config.pagination;

    while (pageNum <= maxPages && allContacts.length < limit) {
      this.logger.info(`[ConfigScraper] Scraping page ${pageNum}: ${currentUrl}`);

      const pageContacts = await this.scrape(
        currentUrl,
        limit - allContacts.length,
        false,
        pageNum,
        url
      );

      if (pageContacts.length === 0) {
        this.logger.info('[ConfigScraper] No contacts found, stopping pagination');
        break;
      }

      allContacts.push(...pageContacts);

      // Get next page
      if (pagination?.type === 'traditional' && pagination.settings?.nextSelector) {
        const page = await this.browserManager.getPage();
        const nextUrl = await this.getNextPageUrl(page, pagination.settings.nextSelector);

        if (!nextUrl) {
          this.logger.info('[ConfigScraper] No next page found');
          break;
        }

        currentUrl = nextUrl;
      } else if (pagination?.type === 'url-pattern' && pagination.settings?.urlPattern) {
        currentUrl = this.buildNextPageUrl(url, pageNum + 1, pagination.settings.urlPattern);
      } else {
        // No pagination or infinite scroll (handled differently)
        break;
      }

      pageNum++;

      // Rate limit between pages
      await this.rateLimiter.wait();
    }

    this.logger.info(`[ConfigScraper] Total contacts extracted: ${allContacts.length}`);

    return allContacts;
  }

  /**
   * Get next page URL from page
   * @param {Object} page - Puppeteer page
   * @param {string} nextSelector - Selector for next button/link
   * @returns {Promise<string|null>} - Next page URL
   */
  async getNextPageUrl(page, nextSelector) {
    try {
      const nextUrl = await page.evaluate((selector) => {
        const nextEl = document.querySelector(selector);
        if (!nextEl) return null;

        // Check if it's a link
        if (nextEl.tagName === 'A') {
          return nextEl.href;
        }

        // Check for href in parent/child
        const link = nextEl.closest('a') || nextEl.querySelector('a');
        return link?.href || null;
      }, nextSelector);

      return nextUrl;
    } catch (error) {
      this.logger.error(`[ConfigScraper] Error getting next page: ${error.message}`);
      return null;
    }
  }

  /**
   * Build next page URL from pattern
   * @param {string} baseUrl - Base URL
   * @param {number} pageNum - Page number
   * @param {string} pattern - URL pattern
   * @returns {string} - Next page URL
   */
  buildNextPageUrl(baseUrl, pageNum, pattern) {
    // Pattern examples: "page={n}", "p={n}", "offset={n*10}"
    let url = baseUrl;

    if (pattern.includes('{n}')) {
      // Simple page number
      if (baseUrl.includes(pattern.split('{n}')[0])) {
        url = baseUrl.replace(/\d+$/, pageNum.toString());
      } else {
        const separator = baseUrl.includes('?') ? '&' : '?';
        url = baseUrl + separator + pattern.replace('{n}', pageNum);
      }
    }

    return url;
  }

  /**
   * Scrape with infinite scroll
   * @param {string} url - URL to scrape
   * @param {number} limit - Max contacts
   * @param {number} maxScrolls - Maximum scroll attempts
   * @returns {Promise<Array>} - All contacts
   */
  async scrapeWithScroll(url, limit = 100, maxScrolls = 50) {
    this.logger.info(`[ConfigScraper] Scraping with scroll: ${url}`);

    const page = await this.browserManager.getPage();
    if (!page) return [];

    try {
      // Navigate
      await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });

      const waitSelector = this.getWaitSelector();
      if (waitSelector) {
        await page.waitForSelector(waitSelector, { timeout: 15000 }).catch(() => {});
      }

      const allContacts = [];
      let scrollCount = 0;
      let noNewContentCount = 0;
      let previousContactCount = 0;

      while (scrollCount < maxScrolls && allContacts.length < limit && noNewContentCount < 3) {
        // Extract current contacts
        let contacts;
        if (this.config.version === '2.0') {
          contacts = await this.extractWithV2Config(page, limit);
        } else {
          contacts = await this.extractWithV1Config(page, limit);
        }

        // Count new contacts
        const newContacts = contacts.filter(c =>
          !allContacts.some(existing =>
            (c.email && existing.email === c.email) ||
            (c.name && existing.name === c.name && !c.email)
          )
        );

        if (newContacts.length === 0) {
          noNewContentCount++;
        } else {
          noNewContentCount = 0;
          allContacts.push(...newContacts);
        }

        this.logger.info(`[ConfigScraper] Scroll ${scrollCount + 1}: ${newContacts.length} new, ${allContacts.length} total`);

        // Scroll down
        await page.evaluate(() => {
          window.scrollBy(0, window.innerHeight * 0.8);
        });

        // Wait for content to load
        await new Promise(r => setTimeout(r, 2000));

        scrollCount++;
        previousContactCount = allContacts.length;
      }

      return allContacts.slice(0, limit);

    } catch (error) {
      this.logger.error(`[ConfigScraper] Scroll scrape error: ${error.message}`);
      return [];
    }
  }
}

module.exports = ConfigScraper;
