/**
 * Config Scraper
 *
 * Scrapes contacts using v2.0 configuration files generated by the
 * Visual Card Scraper. Uses card pattern matching and smart field extraction.
 *
 * Features:
 * - Loads and validates v2.0 config files
 * - Uses card pattern matching to find contact cards
 * - Applies smart field extraction rules
 * - Supports pagination (traditional and scroll-based)
 * - Profile page visiting for enrichment
 */

const BaseScraper = require('./base-scraper');
const CardMatcher = require('../tools/lib/card-matcher');
const SmartFieldExtractor = require('../tools/lib/smart-field-extractor');
const fs = require('fs');
const path = require('path');

class ConfigScraper extends BaseScraper {
  constructor(browserManager, rateLimiter, logger, config = {}) {
    super(browserManager, rateLimiter, logger);

    this.config = config;
    this.cardMatcher = new CardMatcher(logger);
    this.fieldExtractor = new SmartFieldExtractor(logger);
  }

  /**
   * Load configuration from file
   * @param {string} configPath - Path to config file or config name
   * @returns {Object} - Loaded configuration
   */
  loadConfig(configPath) {
    // Try direct path first
    let fullPath = configPath;

    // If not a full path, look in configs directory
    if (!fs.existsSync(fullPath)) {
      fullPath = path.resolve('configs', configPath);
    }

    // Try adding .json extension
    if (!fs.existsSync(fullPath) && !fullPath.endsWith('.json')) {
      fullPath = fullPath + '.json';
    }

    if (!fs.existsSync(fullPath)) {
      throw new Error(`Config file not found: ${configPath}`);
    }

    const content = fs.readFileSync(fullPath, 'utf8');
    const config = JSON.parse(content);

    this.logger.log(`[ConfigScraper] Loaded config: ${config.name} (v${config.version})`);

    return config;
  }

  /**
   * Validate configuration
   * @param {Object} config - Configuration to validate
   * @returns {Object} - Validation result
   */
  validateConfig(config) {
    const errors = [];

    // Check version
    if (!config.version) {
      errors.push('Missing version');
    }

    // For v2.0 configs
    if (config.version === '2.0') {
      if (!config.cardPattern?.selector) {
        errors.push('Missing card pattern selector');
      }
      if (!config.fieldExtraction) {
        errors.push('Missing field extraction configuration');
      }
    }

    // For v1.0 configs
    if (config.version === '1.0' || !config.version) {
      if (!config.selectors?.card) {
        errors.push('Missing card selector');
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors
    };
  }

  /**
   * Main scraping method
   * @param {string} url - URL to scrape
   * @param {number} limit - Maximum contacts to extract
   * @param {boolean} keep - Keep temporary files
   * @param {number} pageNum - Current page number
   * @param {string} sourceUrl - Original source URL
   * @returns {Promise<Array>} - Array of contacts
   */
  async scrape(url, limit = 100, keep = false, pageNum = 1, sourceUrl = null) {
    this.logger.log(`[ConfigScraper] Scraping: ${url} (page ${pageNum})`);

    // Validate config
    const validation = this.validateConfig(this.config);
    if (!validation.valid) {
      this.logger.error(`[ConfigScraper] Invalid config: ${validation.errors.join(', ')}`);
      return [];
    }

    // Get browser page
    const page = await this.browserManager.getPage();
    if (!page) {
      this.logger.error('[ConfigScraper] Failed to get browser page');
      return [];
    }

    try {
      // Navigate to URL
      await page.goto(url, {
        waitUntil: 'networkidle2',
        timeout: 30000
      });

      // Wait for content to load
      const waitSelector = this.getWaitSelector();
      if (waitSelector) {
        try {
          await page.waitForSelector(waitSelector, {
            timeout: this.config.extraction?.waitTimeout || 15000
          });
        } catch (e) {
          this.logger.warn(`[ConfigScraper] Wait selector timeout: ${waitSelector}`);
        }
      }

      // Apply rate limiting
      await this.rateLimiter.wait();

      // Extract contacts based on config version
      let contacts;
      if (this.config.version === '2.0') {
        contacts = await this.extractWithV2Config(page, limit);
      } else {
        contacts = await this.extractWithV1Config(page, limit);
      }

      // Enrich from profiles if configured
      if (this.config.profileVisiting?.enabled) {
        const enrichResult = await this.enrichContactsFromProfiles(contacts, page, this.config);
        contacts = enrichResult.enrichedContacts;
      }

      // Add domain info
      contacts.forEach(contact => {
        this.addDomainInfo(contact);
        contact.sourceUrl = sourceUrl || url;
        contact.pageNum = pageNum;
      });

      this.logger.log(`[ConfigScraper] Extracted ${contacts.length} contacts`);

      return contacts;

    } catch (error) {
      this.logger.error(`[ConfigScraper] Scrape error: ${error.message}`);
      return [];
    }
  }

  /**
   * Get wait selector from config
   * @returns {string|null} - Selector to wait for
   */
  getWaitSelector() {
    if (this.config.version === '2.0') {
      return this.config.cardPattern?.selector || this.config.extraction?.waitFor;
    }
    return this.config.extraction?.waitFor || this.config.selectors?.card;
  }

  /**
   * Extract contacts using v2.0 configuration
   * @param {Object} page - Puppeteer page
   * @param {number} limit - Max contacts
   * @returns {Promise<Array>} - Contacts array
   */
  async extractWithV2Config(page, limit) {
    const contacts = [];

    // Get card selector
    const cardSelector = this.config.cardPattern?.selector;
    if (!cardSelector) {
      this.logger.error('[ConfigScraper] No card selector in v2.0 config');
      return contacts;
    }

    // Find all card elements
    const cardBoxes = await page.evaluate((selector) => {
      const elements = document.querySelectorAll(selector);
      return Array.from(elements).map(el => {
        const rect = el.getBoundingClientRect();
        return {
          x: rect.x + window.scrollX,
          y: rect.y + window.scrollY,
          width: rect.width,
          height: rect.height
        };
      });
    }, cardSelector);

    this.logger.log(`[ConfigScraper] Found ${cardBoxes.length} card elements`);

    if (cardBoxes.length === 0) {
      // Try pattern-based matching as fallback
      return await this.extractWithPatternMatching(page, limit);
    }

    // Extract fields from each card
    const extractedCards = await this.fieldExtractor.extractFromCards(
      page,
      cardBoxes.slice(0, limit)
    );

    // Convert to contacts
    extractedCards.forEach(card => {
      if (card.email || card.name) {
        // Skip duplicates
        if (card.email && this.isEmailProcessed(card.email)) {
          return;
        }

        const contact = {
          name: card.name || null,
          email: card.email || null,
          phone: card.phone || null,
          title: card.title || null,
          location: card.location || null,
          profileUrl: card.profileUrl || null,
          socialLinks: card.socialLinks || [],
          confidence: this.calculateConfidence(card.name, card.email, card.phone),
          extractionConfidence: card.confidence || 0
        };

        if (card.email) {
          this.markEmailProcessed(card.email);
        }

        contacts.push(contact);
      }
    });

    return contacts;
  }

  /**
   * Extract using pattern matching (fallback)
   * @param {Object} page - Puppeteer page
   * @param {number} limit - Max contacts
   * @returns {Promise<Array>} - Contacts array
   */
  async extractWithPatternMatching(page, limit) {
    this.logger.log('[ConfigScraper] Using pattern-based card matching');

    // Use structural/visual patterns from config
    const pattern = this.config.cardPattern;
    if (!pattern?.structural) {
      this.logger.warn('[ConfigScraper] No structural pattern available');
      return [];
    }

    // Inject and run card matcher with stored pattern
    const matchCode = this.cardMatcher.getMatcherCode();
    await page.evaluate(matchCode);

    // Find cards matching the stored pattern
    const result = await page.evaluate((pattern) => {
      // This is a simplified pattern match
      // In production, we'd use the full structural comparison
      const candidates = document.querySelectorAll(pattern.structural.tagName || '*');
      const matches = [];

      candidates.forEach(el => {
        // Basic size check
        const rect = el.getBoundingClientRect();
        if (pattern.visual?.width) {
          const widthRatio = Math.min(rect.width, pattern.visual.width) /
                            Math.max(rect.width, pattern.visual.width);
          if (widthRatio < 0.5) return;
        }

        // Class pattern check
        if (pattern.structural?.classPatterns?.length > 0) {
          const elClasses = Array.from(el.classList).map(c => c.toLowerCase());
          const hasMatch = pattern.structural.classPatterns.some(p =>
            elClasses.some(c => c.includes(p.replace('*', '')))
          );
          if (!hasMatch) return;
        }

        matches.push({
          x: rect.x + window.scrollX,
          y: rect.y + window.scrollY,
          width: rect.width,
          height: rect.height
        });
      });

      return matches;
    }, pattern);

    // Extract from matched cards
    return await this.fieldExtractor.extractFromCards(page, result.slice(0, limit));
  }

  /**
   * Extract contacts using v1.0 configuration (legacy)
   * @param {Object} page - Puppeteer page
   * @param {number} limit - Max contacts
   * @returns {Promise<Array>} - Contacts array
   */
  async extractWithV1Config(page, limit) {
    const contacts = [];
    const selectors = this.config.selectors;

    if (!selectors?.card) {
      this.logger.error('[ConfigScraper] No card selector in v1.0 config');
      return contacts;
    }

    // Extract using explicit selectors
    const extracted = await page.evaluate((config) => {
      const cards = document.querySelectorAll(config.selectors.card);
      const results = [];

      cards.forEach(card => {
        const data = {};

        // Extract name
        if (config.selectors.fields?.name) {
          const nameEl = card.querySelector(config.selectors.fields.name);
          data.name = nameEl?.textContent?.trim() || null;
        }

        // Extract email
        if (config.selectors.fields?.email) {
          const emailEl = card.querySelector(config.selectors.fields.email);
          data.email = emailEl?.textContent?.trim() || null;
        } else {
          // Try to find email in text
          const emailMatch = card.textContent.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/);
          data.email = emailMatch ? emailMatch[0] : null;
        }

        // Extract phone
        if (config.selectors.fields?.phone) {
          const phoneEl = card.querySelector(config.selectors.fields.phone);
          data.phone = phoneEl?.textContent?.trim() || null;
        }

        if (data.email || data.name) {
          results.push(data);
        }
      });

      return results;
    }, this.config);

    // Convert to contacts
    extracted.slice(0, limit).forEach(data => {
      if (data.email && this.isEmailProcessed(data.email)) {
        return;
      }

      const contact = {
        name: data.name || null,
        email: data.email ? data.email.toLowerCase() : null,
        phone: this.normalizePhone(data.phone),
        confidence: this.calculateConfidence(data.name, data.email, data.phone)
      };

      if (contact.email) {
        this.markEmailProcessed(contact.email);
      }

      contacts.push(contact);
    });

    return contacts;
  }

  /**
   * Scrape with pagination support
   * @param {string} url - Starting URL
   * @param {number} limit - Total contacts limit
   * @param {number} maxPages - Maximum pages to scrape
   * @returns {Promise<Array>} - All contacts
   */
  async scrapeWithPagination(url, limit = 100, maxPages = 10) {
    const allContacts = [];
    let currentUrl = url;
    let pageNum = 1;

    const pagination = this.config.pagination;

    while (pageNum <= maxPages && allContacts.length < limit) {
      this.logger.log(`[ConfigScraper] Scraping page ${pageNum}: ${currentUrl}`);

      const pageContacts = await this.scrape(
        currentUrl,
        limit - allContacts.length,
        false,
        pageNum,
        url
      );

      if (pageContacts.length === 0) {
        this.logger.log('[ConfigScraper] No contacts found, stopping pagination');
        break;
      }

      allContacts.push(...pageContacts);

      // Get next page
      if (pagination?.type === 'traditional' && pagination.settings?.nextSelector) {
        const page = await this.browserManager.getPage();
        const nextUrl = await this.getNextPageUrl(page, pagination.settings.nextSelector);

        if (!nextUrl) {
          this.logger.log('[ConfigScraper] No next page found');
          break;
        }

        currentUrl = nextUrl;
      } else if (pagination?.type === 'url-pattern' && pagination.settings?.urlPattern) {
        currentUrl = this.buildNextPageUrl(url, pageNum + 1, pagination.settings.urlPattern);
      } else {
        // No pagination or infinite scroll (handled differently)
        break;
      }

      pageNum++;

      // Rate limit between pages
      await this.rateLimiter.wait();
    }

    this.logger.log(`[ConfigScraper] Total contacts extracted: ${allContacts.length}`);

    return allContacts;
  }

  /**
   * Get next page URL from page
   * @param {Object} page - Puppeteer page
   * @param {string} nextSelector - Selector for next button/link
   * @returns {Promise<string|null>} - Next page URL
   */
  async getNextPageUrl(page, nextSelector) {
    try {
      const nextUrl = await page.evaluate((selector) => {
        const nextEl = document.querySelector(selector);
        if (!nextEl) return null;

        // Check if it's a link
        if (nextEl.tagName === 'A') {
          return nextEl.href;
        }

        // Check for href in parent/child
        const link = nextEl.closest('a') || nextEl.querySelector('a');
        return link?.href || null;
      }, nextSelector);

      return nextUrl;
    } catch (error) {
      this.logger.error(`[ConfigScraper] Error getting next page: ${error.message}`);
      return null;
    }
  }

  /**
   * Build next page URL from pattern
   * @param {string} baseUrl - Base URL
   * @param {number} pageNum - Page number
   * @param {string} pattern - URL pattern
   * @returns {string} - Next page URL
   */
  buildNextPageUrl(baseUrl, pageNum, pattern) {
    // Pattern examples: "page={n}", "p={n}", "offset={n*10}"
    let url = baseUrl;

    if (pattern.includes('{n}')) {
      // Simple page number
      if (baseUrl.includes(pattern.split('{n}')[0])) {
        url = baseUrl.replace(/\d+$/, pageNum.toString());
      } else {
        const separator = baseUrl.includes('?') ? '&' : '?';
        url = baseUrl + separator + pattern.replace('{n}', pageNum);
      }
    }

    return url;
  }

  /**
   * Scrape with infinite scroll
   * @param {string} url - URL to scrape
   * @param {number} limit - Max contacts
   * @param {number} maxScrolls - Maximum scroll attempts
   * @returns {Promise<Array>} - All contacts
   */
  async scrapeWithScroll(url, limit = 100, maxScrolls = 50) {
    this.logger.log(`[ConfigScraper] Scraping with scroll: ${url}`);

    const page = await this.browserManager.getPage();
    if (!page) return [];

    try {
      // Navigate
      await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });

      const waitSelector = this.getWaitSelector();
      if (waitSelector) {
        await page.waitForSelector(waitSelector, { timeout: 15000 }).catch(() => {});
      }

      const allContacts = [];
      let scrollCount = 0;
      let noNewContentCount = 0;
      let previousContactCount = 0;

      while (scrollCount < maxScrolls && allContacts.length < limit && noNewContentCount < 3) {
        // Extract current contacts
        let contacts;
        if (this.config.version === '2.0') {
          contacts = await this.extractWithV2Config(page, limit);
        } else {
          contacts = await this.extractWithV1Config(page, limit);
        }

        // Count new contacts
        const newContacts = contacts.filter(c =>
          !allContacts.some(existing =>
            (c.email && existing.email === c.email) ||
            (c.name && existing.name === c.name && !c.email)
          )
        );

        if (newContacts.length === 0) {
          noNewContentCount++;
        } else {
          noNewContentCount = 0;
          allContacts.push(...newContacts);
        }

        this.logger.log(`[ConfigScraper] Scroll ${scrollCount + 1}: ${newContacts.length} new, ${allContacts.length} total`);

        // Scroll down
        await page.evaluate(() => {
          window.scrollBy(0, window.innerHeight * 0.8);
        });

        // Wait for content to load
        await new Promise(r => setTimeout(r, 2000));

        scrollCount++;
        previousContactCount = allContacts.length;
      }

      return allContacts.slice(0, limit);

    } catch (error) {
      this.logger.error(`[ConfigScraper] Scroll scrape error: ${error.message}`);
      return [];
    }
  }
}

module.exports = ConfigScraper;
